local initialize = require(script.Parent.initialize)
local types = require(script.Parent.types)
type Network = types.Network
type Thenable = types.Thenable
local copy = require(script.Parent.copy)

export type Agent = {
	network: Network,
	fitness: number,
}

local function evolution(params: {
	network: Network,
	population: number,
	epochs: number?,
	mutation: number?,
	spawn: (network: Network, index: number) -> Thenable | number,
	done: ((epoch: number, agents: { Agent }) -> ())?,
}): { Agent }
	local agents: { Agent } = table.create(params.population)

	for index = 1, params.population do
		agents[index] = {
			network = initialize.init.normal(copy(params.network)),
			fitness = 0,
		}
	end

	local function mutate()
		return (math.random() * 2 - 1) * (params.mutation or 0.1)
	end

	-- Combine two networks by randomly selecting biases and weights from either
	-- parent and applying mutations.
	local function crossover(parent: Network, partner: Network)
		local offspring = copy(parent)

		for i, biases in next, offspring.biases do
			for j, weights in next, offspring.weights[i] do
				for k, weight in next, weights do
					weights[k] = mutate() + (math.random() < 0.5 and weight or partner.weights[i][j][k])
				end

				biases[j] = mutate() + (math.random() < 0.5 and biases[j] or partner.biases[i][j])
			end
		end

		return offspring
	end

	-- Returns a function that selects a random agent from the population based
	-- on their fitness values, assuming that the agent population is sorted in
	-- descending order.
	local function distribute()
		-- Shift the fitness values to be non-negative for a uniform distribution.
		local shift = -math.min(0, agents[params.population].fitness) * params.population
		local networks = table.create(params.population)
		local sum = shift

		for index, agent in next, agents do
			sum += agent.fitness
			networks[index] = agent.network
		end

		return function()
			local cursor = math.random() * sum
			local accumulator = shift

			for index, agent in next, agents do
				accumulator += agent.fitness

				if accumulator >= cursor then
					return networks[index]
				end
			end

			error("Failed to select an agent from the population")
		end
	end

	-- The top 20% of agents are selected to be copied directly into the next
	-- generation. The remaining 80% are generated by combining two randomly
	-- selected agents proportional to their fitness values.
	local function evolve()
		table.sort(agents, function(a, b)
			return a.fitness > b.fitness
		end)

		local pick = distribute()

		for index, agent in next, agents do
			if index > params.population * 0.2 then
				agent.network = crossover(pick(), pick())
			end
		end
	end

	-- Run the genetic algorithm for a single epoch, spawning agents (either
	-- sequentially or in parallel) and waiting for all agents to complete
	-- before advancing to the next generation.
	local function simulate()
		local threads = 0

		for index, agent in next, agents do
			local fitness = params.spawn(agent.network, index)

			if type(fitness) == "number" then
				agents[index].fitness = fitness
				continue
			end

			threads += 1

			-- If agents are running in parallel, wait for all agents to complete
			-- before resuming the genetic algorithm.
			fitness:andThen(function(fitness: number)
				threads -= 1
				agents[index].fitness = fitness
			end, function(err)
				threads -= 1
				agents[index].fitness = 0
				warn(`Agent {index} encountered an error:`, err)
			end)
		end

		while threads > 0 do
			task.wait()
		end
	end

	for epoch = 1, params.epochs or 100 do
		if epoch > 1 then
			evolve()
		end

		simulate()

		if params.done and params.done(epoch, agents) then
			break
		end
	end

	return agents
end

return evolution
